<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <!-- JQuery (used for bootstrap and jekyll search) -->
    <script src="/assets/js/jquery-3.2.1.min.js" ></script>
    
    <!-- Main JS (navbar.js and katex_init.js)-->
    <script defer=true src="/assets/js/main.min.js"></script>
    
    <!-- CSS -->
    <link rel="stylesheet" href="/assets/css/main.css">

    <!--Favicon-->
    <link rel="shortcut icon" href="/assets/favicon.ico" type="image/x-icon">

    <!-- Canonical -->
    <link rel="canonical" href="http://localhost:4000/search/">

    <!-- RSS -->
    <link rel="alternate" type="application/atom+xml" title="Tech Blog" href="http://localhost:4000///feed.xml"/>

    <!-- Font Awesome -->
    <!-- <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"> -->
    <link rel="stylesheet" type="text/css" href="/assets/css/font-awesome.min.css">

    <!-- Google Fonts -->
    
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic" rel="stylesheet" type="text/css"> 
    

    <!-- KaTeX 0.8.3 -->
    
    <!--<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.js"></script> -->
    <link rel="stylesheet" type="text/css" href="/assets/css/katex.min.css">
    <script src="/assets/js/katex.min.js">
    </script>
    

    <!-- Google Analytics -->
    
    <script>
        (function(i, s, o, g, r, a, m) {
            i['GoogleAnalyticsObject'] = r;
            i[r] = i[r] || function() {
                (i[r].q = i[r].q || []).push(arguments)
            }, i[r].l = 1 * new Date();
            a = s.createElement(o),
                m = s.getElementsByTagName(o)[0];
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m)
        })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

        ga('create', 'UA-114727309-1', 'auto');
        ga('send', 'pageview');

    </script>
    
    
    <!-- seo tags -->
    <!-- Begin Jekyll SEO tag v2.4.0 -->
<title>Search</title>
<meta name="generator" content="Jekyll v3.7.2" />
<meta property="og:title" content="Search" />
<meta property="og:locale" content="en_US" />
<link rel="canonical" href="http://localhost:4000/search/" />
<meta property="og:url" content="http://localhost:4000/search/" />
<script type="application/ld+json">
{"@type":"WebPage","url":"http://localhost:4000/search/","headline":"Search","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <!-- Manual seo tags -->
    <!--
    <title>Search | Tech Blog</title>
    <meta name="description" content="안드로이드 기술 블로그 입니다.">
    -->
</head>

  <body>
    <header class="site-header">
    
    <!-- Logo and title -->
	<div class="branding">
		<a href="/">
			<img class="avatar" src="/assets/img/my_profile.png" alt=""/>
		</a>

		<h1 class="site-title">
			<a href="/">Tech Blog</a>
		</h1>
	</div>
    
    <!-- Toggle menu -->
    <nav class="clear">
    <a id="pull" class="toggle" href="#">
    <i class="fa fa-bars fa-lg"></i>
    </a>
    
    <!-- Menu -->
    <ul>
        
        
        
        
        
        
        <li>
            <a class="clear" href="/about/">
                About
            </a>
        </li>
        
        
        
        
        
        
        
        
        
        
        
        
        
         
        
        
        <li>
            <a class="clear" href="http://localhost:4000/search">
                <i class="fa fa-search" aria-hidden="true"></i>
            </a>
        </li>
        
        
        <li>
            <a class="clear" href="http://localhost:4000/tags">
                <i class="fa fa-tags" aria-hidden="true"></i>
            </a>
        </li>
        
        
    </ul>
        
	</nav>
</header>

    <div class="content">
      <article class="feature-image">
  <header id="main" style="background-image: url('/assets/img/pexels/search-map.jpeg')">
    <h1 id="Search" class="title">
        Search
    </h1>
    
    
    <h2 class="subtitle">What are you looking for?</h2>
    
      
  </header>
  <section class="post-content"><!-- Html Elements for Search -->
<input type="text" id="search-input" placeholder="Enter keywords..." class="search-bar">
<br>
<br>
<ul id="results-container"></ul>

<section>
    <!-- Script pointing to jekyll-search.js -->
    <script src="/assets/js/simple-jekyll-search.min.js" type="text/javascript"></script>

    <script type="text/javascript">
        SimpleJekyllSearch({
            searchInput: document.getElementById('search-input'),
            resultsContainer: document.getElementById('results-container'),
            json: [
                    
                     
                        {
                          "title"    : "Kotlin 안티패턴#1",
                          "category" : "",
                          "tags"     : " Android, Kotlin",
                          "url"      : "/android/2018/03/05/Kotlin-%E1%84%8B%E1%85%A1%E1%86%AB%E1%84%90%E1%85%B5%E1%84%91%E1%85%A2%E1%84%90%E1%85%A5%E1%86%AB-1.html",
                          "date"     : "March 5, 2018",
                          "content"  : "Kotlin 안티 패턴 #1  해당 글은 Droid Kaigi 2018에서 발표했던 Kotlinアンチパターン을 번역한 글입니다.Kotin 안티패턴 #1 에서 다뤄 볼 주제      lateinit 과 null 초기화        Scope 함수        Nullable 과 NonNull  lateinit 과 null 초기화lateinit에 대해서Java에서는 초기값을 설정하지 않고 변수 선언을 했을 경우 null 이 들어갑니다.TextView message;	// null 이 들어갑니다.Kotlin에서는 기본적으로 초기값을 설정하지 않으면 안됩니다.var message: TextView	// error가 발생됩니다.var message: TextView? = null	// OKAndroid에서는 onCreate() 이후로 초기화 하는것이 많습니다.Kotlin에서 초기값을 설정하는게 필수입니다.아래 예시는 TextView를 null 로 초기화 하였기 때문에실질적으로 NonNull이었던 부분이 전부 Nullable로 되어버립니다.var message: TextView? = nullfun clear() {  message!!.text =\"\"  message?.text = \"\"}Kotlin에서 초기값을 설정하는게 필수지만 lateinit을 사용하면 선언할 때 초기값을 넣지 않아도 됩니다.lateinit var message: TextView	// OK단 값을 초기화 하지 않은 상태에서 해당 값을 참조하게 되면 UninitializedPropertyAccessException이 발생됩니다.lateinit을 사용하는 곳인스턴스 생성할 때 값이 정해지지 않았지만 onCreate(), onCreateView()에 대입해야할 경우 사용하면 됩니다.예시)  findViewById를 한 View  DataBinding의 binding  Dagger등의 DI에 의해 inject 될 것단 원시 타입(int, float, long, …)이나 Nullable에는 lateinit을 사용할 수 없습니다.lateinit 안티패턴통신 후 얻는 정보를 lateinit로 할 경우lateinit var profile: Profilefun init() {    fetchProfile().subscribe { profile -&gt;        this.profile = profile    }}미리 listener를 설정하면통신 중이거나 통신 에러시에 접속해 UninitializedPropertyAccessException이 발생됩니다.button.setOnClickListener {    textView.text = profile.name}해결방법Nullable로 하고 항상 “값을 못받았을 경우 어떻게 할까?” 라는 생각을 하는게 좋습니다.var profile: Profile? = null	// Nullable 설정fun init() {    fetchProfile().subscribe { profile -&gt;        this.profile = profile    }}onCreate() / onCreateView() 에서 초기화가 가능한다면 lateinit을 사용해도 됩니다.onCreate() / onCreateView() 이후에 값이 정해지면 Nullable로 하거나 멤버 변수를 사용하는것을 피하시는게 좋습니다.isInitializedKotlin 1.2부터 isInitialized가 추가되었습니다.값이 대입되었는지 여부를 확인 할 수 있습니다.lateinit var str: Stringfun foo() {    val before = ::str.isInitialized	// false    str = \"hello\"    val after = ::str.isInitialized		// true}isinitialized는 원래 테스트 코드에서 이용하려고 추가되었습니다.isInitialized를 일상적으로 사용하면 더이상 null이 안전하지 않으므로 프로덕션 코드에서 사용 안하시는게 좋습니다.private lateinit var file: File@Afterfun tearDown() {    // 파일 만들기 전에 fail하면 에러가 발생    file.delete()}Scope 함수scope 함수 종류에는 let/ run/ also/ apply/ with 5개가 있습니다.with를 제외하면 대략적 다음과 같이 분류 할 수 있습니다.반환값 = 자신.scope함수 {    리시버.method()    결과}Scope 함수를 사용하는 곳 #1null 관련 제어에 유용합니다.str?.let {    //	str이 null이 아닐 경우}val r = str ?: run {    // str이 null인 경우}Scope 함수를 사용하는 곳 #2초기화 처리를 정리하고 싶을 경우 사용하면 좋습니다.val intent = Intent().apply {    putExtra(\"key\", \"value\")    putExtra(\"key\", \"value\")    putExtra(\"key\", \"value\")}Scope 함수 안티패턴apply 범위 내에서 프로퍼티 접근 형식을 사용할 때val button = Button(context)button.text = \"hello\"	// Java의 setText(..)가 호출됨// ... button의 설정이 이어짐 ...↓ apply를 사용하여 설정을 정리val button = Button(context).apply {    text = \"hello\"    // ... button의 설정이 이어짐 ... }로컬 변수를 정의하면 접근 범위가 바뀝니다.fun init() {    var text = \"\"	// text 라는 변수가 추가 될 경우    val button = Button(context).apply {        text = \"hello\"    }    button.text	// \"hello\" 가 되지 않음}해결방법 #1apply 범위 내에서는 프로퍼티 접근 형식을 사용하지 않고 일반 함수를 호출하는 방법val button = Button(context).apply {    setText(\"hello\")}단 로컬 함수(setText와 이름이 동일한 함수) 가 정의되어 있을 경우 같은 문제가 발생합니다.해결방법 #2this를 필수로 사용하는 방법 (also와 비슷한 느낌)val button = Button(context).apply {    this.text = \"hello\"}해결방법 #3apply를 사용하는 대신 also를 사용하는 방법val button = Button(context).also {    it.text = \"hello\"}Nullable 과 NonNullNullable/ NonNull은 Kotlin의 큰 매력 중 하나 입니다.val nullable: String? = null	// OKval nonNull: String = null	// 잘못됨nullable.length	// 잘못됨nullable!!.length	// OKnullable?.length	// OKnonNull.length	// OKNullable 과 NonNull 안티패턴 #1Nullable 그대로 데이터를 사용하게 되면data class User(    val id: Long = null,    val name: String? = null,    val age: Int? = null)Nullable 데이터를 사용할 때 곳곳에서 null 체크를 하거나 safe call를 하는 처지가 됩니다.return team?.user?.name?.length→ 실질적으로 조건 분기가 늘어나 파악하기 어려워 집니다.→ “뭐가 null이 였지?”에 대해 매번 생각하게 됩니다.Nullable 과 NonNull 안티패턴 #2모든 변수를 NonNull로 하기 위해 잘못된 데이터를 집어 넣으면val response = ...return User(    id = respon.id ?: 0L,    name = response.name.orEmpty(),    age = response.age ?: 0)if(user.name.isNotEmpty()) {    // 골치 아픔 or 잊어버림}→ 잘못된 데이터인지 확인하는 처지가 됩니다.→ 체크를 잊어 오류가 생깁니다.해결방법“null이 무엇을 나타내는지” 로 처리하는 레이어를 정해야합니다.  API에서 전달해주지 않았기 때문 → API 레이어에서 처리  사용자가 설정하지 않았기 때문 → UI 레이어에서 처리  명백하지 않고 레이어를 넘었을 경우 → 클래스에서 명확화데이터 표현에 대해 곤란했을 경우 null에 의존하지 않습니다. (예외 던지기, 다른 클래스로 하기 ,…)  [출처] : https://www.slideshare.net/RecruitLifestyle/kotlin-87339759"
                        } ,
                     
                        {
                          "title"    : "RxJava를 잘 다룰수 있는 5가지 Tip",
                          "category" : "",
                          "tags"     : " Android, RxJava",
                          "url"      : "/android/2018/02/22/RxJava%E1%84%85%E1%85%B3%E1%86%AF-%E1%84%8C%E1%85%A1%E1%86%AF-%E1%84%83%E1%85%A1%E1%84%85%E1%85%AE%E1%86%AF%E1%84%89%E1%85%AE-%E1%84%8B%E1%85%B5%E1%86%BB%E1%84%82%E1%85%B3%E1%86%AB-5%E1%84%80%E1%85%A1%E1%84%8C%E1%85%B5-Tip.html",
                          "date"     : "February 22, 2018",
                          "content"  : "RxJava를 잘 다룰수 있는 5가지 TipRxJava를 처음 사용하거나 알고 있어도 항상 배워야 할 새로운 것이 있습니다.해당 5가지 Tip을 알게 되면 RxJava를 좀 더 능숙하게 다룰 수 있게 됩니다.  해당 글은 RxJava 1.2.6 에서 사용할 수 있는 API를 참조합니다.1. map 과 flatmap을 사용하는 시점map과 flatmap은  ReactiveX 에서 자주 사용 되는 연산자 입니다.하지만 해당 연산자들을 언제 써야할지 잘 모르는 경우가 있습니다.map과 flatmap은 Observable에서 방출된 각각의 아이템들을 변환시키기 위한 연산자 입니다.map은 항목 하나만 내보내는 반면 flatmap은 0개 이상의 항목을 내보냅니다.위 예제를 보면 map연산자는 split함수를 이용하여 각 문자열 마다 적용하여 문자열 배열을 포함하는 하나의 항목을 내보냅니다. 하나의 항목을 다른 항목으로 변환하고 싶을 경우 이 연산자를 사용하면 됩니다.하지만 위 문자열들을 하나의 단일 스트림에 추가하고 싶을 경우에는 flatmap을 사용하면 됩니다.flatmap연산자는 single sequence로 방출된 단어의 배열을 flattens 하게 만듭니다.2. Observable.create(…)를 사용하여 observables를 생성하지 않도록 한다개발하다 보면 기존의 동기식 또는 비동기식 API를 반응식 API로 변환해야할 경우가 있습니다.Observable.create를 사용하여 개발할 수 있지만 다음과 같은 방식을 따라야 합니다.  Observable 구독 취소 시 callback 등록 취소 (그렇게 하지 않을 경우 메모리 누수가 발생할 수 있음)  구독자가 구독하고 있을 경우에만 onNext 또는 onCompleted를 사용하여 이벤트를 보내야함  onError를 사용하여 upstream으로 오류를 전파해야함  backpressure 조절위와 같은 요구사항을 따르며 직접 구현하는것은 어렵지만 다행히도 직접 구현하지 않아도 됩니다. RxJava에서 이를 위해 몇가지 static helper method를 제공합니다.SyncOnSubscribeOnSubscribe&lt;T&gt; 구현은 끌어오기(pull) 기반이며 backpressure를 명로하게 내장했습니다. SyncOnSubscribe 는 backpressure이 가능한 Observable을 제작할 수 있게 도와주는 편리한 유틸리티입니다.  backpressure가 이해가 안되신 분들은 ‘3. backpressure를 다루는 방법’을 읽고 오시길 바랍니다.public Observable&lt;byte[]&gt; readFile(@NonNull FileInputStream stream) {  final SyncOnSubscribe&lt;FileInputStream, byte[]&gt; fileReader = SyncOnSubscribe.createStateful(    () -&gt; stream,    (stream, output) -&gt; {      try {        final byte[] buffer = new byte[BUFFER_SIZE];        int count = stream.read(buffer);        if (count &lt; 0) {          output.onCompleted();        } else {          output.onNext(buffer);        }      } catch (IOException error) {        output.onError(error);      }      return stream;    },    s -&gt; IOUtil.closeSilently(s));  return Observable.create(fileReader);}fromCallable단순한 동기 API를 wrapping 하여 반응형 API로 변환하는데 유용한 static helper입니다. 추가로 fromCallable는 예외도 처리합니다.public Observable&lt;Boolean&gt; enablePushNotifications(boolean enable) {  return Observable.fromCallable(() -&gt; sharedPrefs    .edit()    .putBoolean(KEY_PUSH_NOTIFICATIONS_PREFS, enable)    .commit());}fromEmitterObservable이 unsubscribed 되었을 때 비동기 API를 wrapping 하고 리소스를 관리하는데 유용한 static helper입니다. fromCallable과 달리 여러 항목을 내보낼 수 있습니다.import android.bluetooth.le.BluetoothLeScanner;import android.bluetooth.le.ScanCallback;import android.bluetooth.le.ScanResult;import android.support.annotation.NonNull;import rx.Emitter;import rx.Observable;import java.util.List;public class RxBluetoothScanner {    public static class ScanResultException extends RuntimeException {        public ScanResultException(int errorCode) {            super(\"Bluetooth scan failed. Error code: \" + errorCode);        }    }        private RxBluetoothScanner() {    }    @NonNull    public static Observable&lt;ScanResult&gt; scan(@NonNull final BluetoothLeScanner scanner) {        return Observable.fromEmitter(scanResultEmitter -&gt; {            final ScanCallback scanCallback = new ScanCallback() {                @Override                public void onScanResult(int callbackType, @NonNull ScanResult result) {                    scanResultEmitter.onNext(result);                }                @Override                public void onBatchScanResults(@NonNull List&lt;ScanResult&gt; results) {                    for (ScanResult r : results) {                        scanResultEmitter.onNext(r);                    }                }                @Override                public void onScanFailed(int errorCode) {                    scanResultEmitter.onError(new ScanResultException(errorCode));                }            };                        scanResultEmitter.setCancellation(() -&gt; scanner.stopScan(scanCallback));            scanner.startScan(scanCallback);        }, Emitter.BackpressureMode.BUFFER);    }}3. Backpressure를 다루는 방법Observable가 이벤트를 너무 빨리 생성했을 경우 Observer downstream은 이벤트를 처리할 수 없게 됩니다.이럴때 우리들은 MissingBackpressureException을 만나게 됩니다.RxJava는 backpressure를 다룰 수 있는 몇가지 방법을 제공하지만 상황에 따라 선택하는게 좋습니다.Cold vs Hot ObservablesCold Observable는 subscribe 할 경우 아이템들을 방출하기 시작합니다.Cold Observable의 예로는 File 읽기, 데이터베이스 쿼리, 웹 요청, 정적 iterable를 Observable 변환 등 이 있습니다.Hot Observable는 subscribe과 관계 없이 연속적으로 이벤트를 방출합니다. Observer가 Hot Observable를 subscribe하면 다음중 하나를 수행할 수 있습니다.  방출되었던 모든 이벤트의 일부분을 받습니다.  방출되었던 모든 이벤트를 받습니다.  새로운 이벤트가 발생할 때 받습니다.Hot Observable의 예로는 터치 이벤트, 알림, 업데이트 진행 등 이 있습니다.Hot Observable은 이벤트를 연속적으로 방출하기 때문에 사용자는 속도를 제어 할 수 없습니다.예를들어 터치이벤트가 발생했을 경우 사용자는 터치이벤트의 속도를 제어할 수 없습니다. 따라서 아래 전략중 하나를 사용하는것이 가장 좋습니다.BackpressureMode.NONE 과 BackPressureMode.ERROR이 두개의 Mode에서 방출된 이벤트는 backpressure이 되지 않습니다.observeOn의 내부 16 element 크기의 buffer가 overflow가 발생했을 경우 MissingBackpressureException가 나타납니다.BackpressureMode.BUFFER이 모드에서는 초기 크기가 128인 무한 buffer가 만들어집니다. 너무 빨리 방출된 항목은 무제한으로 버퍼링됩니다. buffer가 소모되지 않으면 항목은 메모리가 모두 소모 될 때 까지 계속 누적됩니다. 결국 OutOfMemoryException을 만나게 됩니다.BackpressureMode.DROP이 모드에서는 크기가 1인 고정 buffer를 사용합니다. downstream observable는 유지되지 않으면 첫번째 항목이 버퍼링되고 그 다음 방출된 이벤트들이 삭제됩니다. consumer가 다음 값을 받을 수 있는 상태가 되면 **Observable **이 방출한 첫번째 값을 받습니다.BackpressureMode.LATEST이 모드는 BackpressureMode.DROP과 비슷합니다. 이 모드도 역시 크기가 1인 고정 버퍼를 사용합니다. 그러나 첫번째 항목을 버퍼링 하고 그 다음 방출된 이벤트를 삭제하는게 아니라 BackpressureMode.LATEST는 버퍼의 항목을 최신 방출로 바꿉니다. consumer가 다음 값을 받을 수 있는 상태가 되면 Observable이 방출한 최신 값을 받습니다.4. 실수로 스트림을 종료하는 실수를 방지하는 방법RxJava는 Observable sequence에 오류가 발생했을 경우 sequence를 종료하고 sequence에 알림을 보내 해당 오류를 전달합니다.하지만 sequence의 종료를 원하지 않을 수도 있습니다. 이러한 경우 RxJava는 sequence를 종료하지 않고도 오류를 처리 할 수 있는 다양한 방법을 제공합니다.onErrorResumeNextonErrorResumeNext 를 사용하게 되면 해당 오류를 가로챌 수 있고 다른 Observable값으로 반환할 수 있습니다.오류를 추가 정보로 wrap 하고 새 오류를 반환하거나 수신할 새로운 이벤트로 반환할 수 있습니다.public Observable&lt;SearchResult&gt; search(@NotNull EditText searchView) {  return RxTextView.textChanges(searchView)     .map(CharSequence::toString)    .debounce(500, TimeUnit.MILLISECONDS)       .filter(s -&gt; s.length() &gt; 1)                .observeOn(workerScheduler)                 .switchMap(query -&gt; searchService.query(query))       .onErrorResumeNext(Observable.empty()); // 에러가 발생할 경우 텍스트 뷰 변경을 중단}onErrorResumeNext 연산자를 사용하면 down stream sequence를 복구하지만 onError 알림이 생성되었으므로 upstream sequence가 종료됩니다. 만약 Subject를 사용할 때 onError 알림이 발생했을 경우 Subject는 종료됩니다.upstream을 계속 실행하고 싶다면 Observable를 onErrorResumeNext 연산자의 flatMap 또는 switchMap 연산자 내부에 선언하면 됩니다.public Observable&lt;SearchResult&gt; search(@NotNull EditText searchView) {  return RxTextView.textChanges(searchView)     .map(CharSequence::toString)    .debounce(500, TimeUnit.MILLISECONDS)       .filter(s -&gt; s.length() &gt; 1)                .observeOn(workerScheduler)                 .switchMap(query -&gt; searchService.query(query)       			.onErrorResumeNext(Observable.empty())); }5. Observable을 공유하는 방법때때로 Observable의 결과물을 여러 Observer과 공유해야할 때가 있습니다. Observable에서 RxJava로 방출 된 이벤트를 multicast 하는 두가지 방법은 share 과 publish 이 있습니다.Shareshare 연산자를 사용하면 여러 Observer가 Observable에 연결하여 방출된 이벤트를 공유할 수 있습니다 .아래 예제에서 Observable는 MotionEvent 아이템들을 방출합니다. 그런 다음 DOWN 및 UP 터치 이벤트를 걸러낼 두개의 Observable들을 만듭니다.Down이벤트들은 빨강색 원을 그리고 UP이벤트들은 파란색 원을 그립니다.public void touchEventHandler(@NotNull View view) {  final Observable&lt;MotionEvent&gt; motionEventObservable = RxView.touches(view).share();  // Capture down events  final Observable&lt;MotionEvent&gt; downEventsObservable = motionEventObservable    .filter(event -&gt; event.getAction() == MotionEvent.ACTION_DOWN);  // Capture up events  final Observable&lt;MotionEvent&gt; upEventsObservable = motionEventObservable    .filter(event -&gt; event.getAction() == MotionEvent.ACTION_UP);  // Show a red circle at the position where the down event ocurred  subscriptions.add(downEventsObservable.subscribe(event -&gt;      view.showCircle(event.getX(), event.getY(), Color.RED)));  // Show a blue circle at the position where the up event ocurred  subscriptions.add(upEventsObservable.subscribe(event -&gt;      view.showCircle(event.getX(), event.getY(), Color.BLUE)));}Observer가 Observable를 subscribe 했을 경우 이벤트가 방출되기 시작됩니다. 이벤트가 방출되고나서 subscribe 했을 경우 앞에 방출되었던 이벤트를 놓치게 되기 때문에 문제가 됩니다.위 예제에서 파란색 Observer는 첫번째 값이 방출되고 난 이후 subscribe 했기 때문에 해당 이벤트를 놓치게 됩니다. 이벤트를 놓치고 싶지 않다면 publish 연산자를 사용하면 됩니다.Publishpublish 연산자를 호출 했을 경우 Observable는 ConnectedObservable로 변화합니다.아래 예제는 publish연산자를 사용한 부분을 제외하고 위 예제와 동일합니다.public void touchEventHandler(@NotNull View view) {  final ConnectedObservable&lt;MotionEvent&gt; motionEventObservable = RxView.touches(view).publish();  // Capture down events  final Observable&lt;MotionEvent&gt; downEventsObservable = motionEventObservable    .filter(event -&gt; event.getAction() == MotionEvent.ACTION_DOWN);  // Capture up events  final Observable&lt;MotionEvent&gt; upEventsObservable = motionEventObservable    .filter(event -&gt; event.getAction() == MotionEvent.ACTION_UP);  // Show a red circle at the position where the down event ocurred  subscriptions.add(downEventsObservable.subscribe(event -&gt;      view.showCircle(event.getX(), event.getY(), Color.RED)));  // Show a blue circle at the position where the up event ocurred  subscriptions.add(upEventsObservable.subscribe(event -&gt;      view.showCircle(event.getX(), event.getY(), Color.BLUE)));  // Connect the source observable to begin emitting events  subscriptions.add(motionEventObservable.connect());}Observable를 subscribe 해도 바로 이벤트가 방출되지 않고 ConnectedObservable의 connect를 호출하면 이벤트가 방출되기 시작합니다.connect가 호출되고 난 뒤에는 같은 이벤트의 동일한 순서가 녹색 및 파란색 Observer들에게 모두 방출됩니다.  [출처] : https://medium.com/@jagsaund/5-not-so-obvious-things-about-rxjava-c388bd19efbc"
                        } ,
                     
                        {
                          "title"    : "MVVM 패턴",
                          "category" : "",
                          "tags"     : " Android, Architecture, MVVM",
                          "url"      : "/android/2018/02/07/Model-View-ViewModel.html",
                          "date"     : "February 7, 2018",
                          "content"  : "Model - View - ViewModelMVVM(Model-View-ViewModel)은 Microsoft의 Ken Cooper와 Ted Peters가 개발한 아키텍처입니다.데이터 바인딩 메커니즘을 사용한 UI부분의 추상화가 특징입니다.MVVM의 개념은 세 가지 역할(Model, View, ViewModel)로 구성되어 있으며, 유저 인터페이스 (UI)의 분리를 목적으로 한 아키텍처 입니다. (그림 1.6)어플리케이션의 UI와 비즈니스 로직을 연관 데이터 바인딩을 이용하여 관계를 분리합니다. View의 추상화를 실시하여 비즈니스 로직, 도메인 모델 안에 있는 View에 관련된 글루 코드를 없애는 메리트가 있습니다.  글루코드 : 컴퓨터 프로그래밍 에서 프로그램의 요구 사항의 실현에는 일절 기여하지 않지만, 원래 호환되지 않는 부분끼리를 결합하는 데에만 작동 코드 이다. 예를 들어 함수 인터페이스가 있다.ModelModel은 어플리케이션 도메인 모델을 말합니다. 데이터 구조 외에 비즈니스 로직을 표현하는 수단도 모델에 포함되어 있습니다.ViewView는 사용자가 보는 구조, 레이아웃, 모양을 정의하는 역할을 담당합니다. 비즈니스에 관련된 로직에서 분리되어 있습니다.View ModelViewModel은 Model과 View의 중재자입니다. 표시에 관련된 로직을 담당합니다.Model을 조작하고 View가 사용하기 쉬운 형태로 데이터를 제공하는 역할을 합니다.ViewModel은 View를 Model로부터 격리하고 Model과 View를 독립적으로 진화시키기 위한 것입니다. View는 ViewModel을 알고 있으며, ViewModel은 Model을 파악하고 있습니다. 반대로 Model은 ViewModel을 인식하지 못하고 ViewModel도 View에 대해 알지 못합니다. 각각 독립성을 높이고 (캡슐화), 관심사를 분리하고 효율적인 개발을 목표로하고 있습니다.데이터바인딩MVVM등장 배경에는 데이터 바인딩 (Data Binding)구조의 발전이 있습니다.데이터 바인딩은 데이터 표현과 사용자 인터페이스를 정적 또는 동적으로 바인딩 할 수있는 구조입니다.데이터 표현은 XML, XAML 등의 마크 업 언어가 사용됩니다. 기능에 따라 2 종류로 분류 할 수 있습니다. (그림 1.7)단방향 데이터 바인딩표시 할 데이터가 변경되면 그에 따라 사용자 인터페이스에 변화를 반영화하는 단방향 바인딩양방향 데이터 바인딩단방향 이외에, 사용자 인터페이스의 변경 또는 조작에 따라 데이터도 변경해야하는 양방향 데이터 바인딩MVVM의 도입은 데이터 바인딩 또는 유사한 구조를 가진 플랫폼이 전제입니다. MVVM이 ViewModel에 의해 Model과 View를 분리하는 특성상 ViewModel에서는 View에 표시되는 데이터를 조립하고 반영해야합니다.복잡한 UI작업을 서포트하는 구조가 데이터 바인딩입니다.플랫폼의 적용 예로는 Android에서 XML 및 Java 코드의 바인딩, WPF와 Silverlight 플랫폼을 기반으로 한 XAML과 C # 소스 코드의 바이딩을 들 수 있습니다. JavaScript의 세계에서 DOM (Document Object Model)과 JavaScript 소스 코드를 바인딩하는 형태로 MVVM의 적용 예가 있습니다.MVVM아키텍처에서 데이터 바인딩의 역할은 큰 것입니다.MVVM의 기반 개념 : Presentation ModelMVVM은 Martin Fowler의 Presentation Model을 기반으로하고 있습니다.  Presentation Model: https://martinfowler.com/eaaDev/PresentationModel.htmlMVVM의 기반으로 하고 있는Presentation Model은 View표시에 관한 정보를 관리하는Presentation Model의 상태를 그대로 반영합니다. Presentation Model에서 데이터에 변화가 있으면 View에 설정하고 View측에서 사용자 이벤트가 발생하면 신속하게 PresentationModel에 통지합니다.이 설정 및 알림 작업은 View의 상태를 도메인 모델에서 분리하는 데 필수적입니다.이 View (가 제공하는 UI)가 복잡할수록 설정 및 알림 시간이 개발자의 부담입니다.(바인딩을 위한 코드를 손으로 쓰는 것은 생각보다 귀찮은 것입니다).소프트웨어 개발의 진화함에 따라 Presentation Model과 View동기화하는 PresentationModel 성가신 부분을 데이터 바인딩 메커니즘으로 실현할 수있게 된 것은 기술적인 성과였습니다.MVVM아키텍처는 데이터 바인딩메커니즘을 사용하여 Presentation Model을 개발시켜 (국소 적으로 자동 생성을 사용하여 최적화), View와 Model의 분리를 추진하고 있다고 합니다.  [출처] : Android アプリ設計パターン入門"
                        } 
                     ,
                     
                    
                  ],
            searchResultTemplate: '<div class="search-title"><a href="{url}"><h3> {title}</h3></a><div class="meta">{date} <div class="right"><i class="fa fa-tag"></i> {tags}</div></div><p>{category}</p></div><hr> ',
            noResultsText: 'No results found',
            limit: 10,
            fuzzy: true,
            exclude: []
        })
    </script>
</section>
</section>
    
    
  <!-- Tag list for portfolio -->
  
  



    
</article>

    </div>
    
<footer class="site-footer">
    <p class="text">Copyright ©dhha22. All rights reserved</p>
            <div class="footer-icons">
                <ul>
                <!-- Social icons from Font Awesome, if enabled -->
                


<li>
	<a href="mailto:dhha77@gmail.com" title="Email">
		<span class="fa-stack fa-lg">
            <i class="fa fa-circle fa-stack-2x"></i>
            <i class="fa fa-envelope fa-stack-1x fa-inverse"></i>
        </span>
	</a>
</li>













<li>
	<a href="https://github.com/dhha22" title="Follow on GitHub">
		<span class="fa-stack fa-lg">
            <i class="fa fa-circle fa-stack-2x"></i>
            <i class="fa fa-github fa-stack-1x fa-inverse"></i>
        </span>
	</a>
</li>
































                </ul>
            </div>
</footer>




  </body>
</html>
